### Вопросы по операционным системам. Часть 2.

#### Что такое процесс?

Определение *процесса* довольно таки просто - это работающая в данный момент *программа*, а выделенные под нее ресурсы - *контекст процесса*. *Программа* является безжизненной вещью, располагающейся на диске - это набор инструкций и, возможно, каких-то статических данных, ожидающих момента запуска. Именно операционная система берет эти данные и запускает их. Однако пользователи хотят запускать несколько программ одновременно. Фактически, система может запускать огромное количество процессов одновременно. Данное решение облегчает жизнь пользователем, потому что не нужно дкмать, занята ли система в данный момент.

#### В чем отличие системных процессов от пользовательских процессов и процессов демонов?

В *ОС Linux* все процессы разделяются на:
- **Системные**. Они являются частью ядра.
- **Демоны**. Выполняют роль сервисов и не взаимодействуют с пользователем напрямую.
- **Пользовательские**.

Ключевое отличие **системных процессов** от отстальных заключается в способе обращения к памяти: системные процессы могут обращаться ко *всей области памяти* и адресуют свои данные по ее *физическим адресам* ("Kernrelspace"). А **пользовательские процессы** могут обращаться только к *строго отведенным для них участкам* и делать это по *виртуальным адресам* ("Userspace").

#### Что такое виртуальные адреса? В чем необходимость их использования?

**Виртуальные адреса** - это адреса, которые не указывают напрямую ни на какие физические адреса в имеющейся оперативной памяти. Всегда, когда осуществляется доступ к памяти, выполняется *механизм трансляции* для подбора соответствующей физической памяти.

Организация хранения контекста пользовательских процессов через **виртуальные адреса** имеет несколько *приемуществ*:
1. Каждая программа всегда обращается к одним и тем же адресам, вне зависимости от того, где реально расположенны ее данные, что позволяет *оптимально распределять память между процессами* и не требует *перекомпоновки программы* из объектных файлов перед каждым вызовом.
2. Изолированные области данных между процессами *повышают стабильность системы* - ни один процесс не может испортить данные другого процесса.

#### Что такое виртуальные адреса? Какие недостатки использования виртуальных адресов вы видите?

Применение виртуальных адресов не позволяет пользовательским процессам обмениваться данными между собой напрямую, что требует от операционной системы наличия механизмов межпроцессорного взаимодействия (**IPC** - InterProcess Communications).

#### Что такое PID и для чего он используется? Что такое PPID?

Каждому процессу ОС Linux присваивается собственный уникальный номер, который называется **PID** (*Process Identidier*) и с помощью которого осуществляется идентификация этого процесса. Информация о всех процессах хранится в виртуальной дирректории `/proc`. Внутри данной дирректории для каждого процесса создается своя поддирректория `/proc/PID`, в которой располагаются виртуальные файлы со служебной информацией о текущем состоянии процесса, объеме выделенной памяти, использованных системных вызовов и т.д.

У каждого процесса в системе помимо его собственного **PID** есть также и информация о его родительском процессе - **PPID** (*Parent Process Identifier*). В случае, если родительский процесс завершился раньше дочернего, **PPID** у последнего изменяется на значение 1 (процесс `init`), поскольку данный процесс не может быть завершен, пока работает операционная система.

#### Что такое зомби-процесс? Какая опасность заключается в данных процессах?

В случае если дочерний процесс завершился, а родительский процесс не считал его код завершения, дочерний процесс становится **зомби-процессом** - фактически он завершил выполнение и освободил ресурсы, но присутствует в списке процессов до тех пор, пока код завершения не будет считан родительским процессом или родительский процесс не завершит свою работу. В списке процессов (при использовании команды `ps -f`) он помечается буквой `Z`.

#### Чем иерархия процессов в Linux отличиется от иерархии процессов в Windows?

В отличии от ОС Windows, в которой процессы не имеют организованной структуры, подсистема управления процессами в ядре Linux построена по принципу ориентированного дерева: каждый процесс может быть запущен только одним из ранее запущенных процессов. В вершине дерева пользовательских процессов находится процесс-демон init (PID равный 1), который зачастую в современных дистрибутивах ОС Linux заменяется процессом-демоном systemd

#### Предложите решение проблем блокирования командной оболочки при запуске процесса?

Большинство процессов, запущенных на машине Linux, работает на переднем плане. При этом выполняемые команды будут блокировать оболочку на период выполнения. Процесс может быть интерактивным. После выполнения процесса в терминале появится вывод.

Используются слудующие сочетания клавиш для работы с процессами:
- `Ctrl+C` - завершение работы процесса.
- `Ctrl+Z` - остановка процесса.

Также процессы можно запускать в фоновом режиме. Фоновый процесс связан с отдельным терминалом, но не блокирует доступа к оболочке, то есть пользователь может взаимодействовать с системой во время выполнения процесса. Чтобы запустить процесс в фоновом режиме, нужно воспользоваться знаком `&` на конце команды. Например `ping google.com &`.

#### В чем отличие именованных от неименованных каналов?

В ОС Linux существуют различные механизмы информационного обмена между процессами (*IPC*):
- Сигналы.
- Неименованные каналы (*pipe*).
- Именованные каналы (*fifo*).

Механизмы неименованных и именованных каналов предназначены для обмена большим объемом информации и построены на применении потоков ввода-ввода.

Основное отличие между pipe и FIFO - то, что pipe могут совместно использовать только процессы находящиеся в отношении родительский-дочерний, а FIFO может использовать любая пара процессов.

#### В каких случаях предпочтительно использовать именованные, а в каких неименованные каналы? Приведите пример.

**Именованный канал** используется, когда требуется доступ к промежуточным данным или требуется передача в процесс-приемник данных от нескольких процессов-источников. Например,

```bash
mkfifo fifofile
echo "Moscow" > fifofile & # Запускается в фонофом режиме
echo "saint-Peterthburg" > fifofile & # Запускается в фоновом режиме
```

После того, как будет вызвана команда `cat`, именованный канал `fifofile` открывается на чтение, команды `echo` записывают в файл данные. Эти данные считываются командой `cat` и выводятся на экран, после чего работа фоновых команд `echo` завершается.

**Неименованный канал** используется, когда необходима конвейерная обработка данных, в которой первый процесс выступает источником, а каждый последующий процесс обрабатывает данные предыдущего. Например, если требуется удалить все поддиректории с пометкой «tmp» в рабочей директории, то при вызове команды

```bash
ls | grep "tmp" | xargs rm -r
```

#### Что такое механизм сигналов?

**Механизм сигналов** по своей сути схож с механизмом аппаратных прерываний [7]: любой из процессов в ОС может сгенерировать отправку сигнала остальным процессам, а они, в свою очередь, при получении сигнала могут незамедлительно прервать свое штатное исполнение и перейти в соответствующую функцию-обработчик.
